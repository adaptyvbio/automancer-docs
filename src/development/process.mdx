{/* Category: Conceptual guide */}


export const title = 'Processes';


# Tutorial: Creating a simple process

## Introduction

This tutorial will guide you through the process of creating a simple process. The process will be a simple timer with support for halting, but without pause/resume or jumping, unlike the [built-in timer](../../modules/timer).

This timer plugin will have three main components:

- A parser that understands the `sleep` attribute and validates its argument.
- A process that executes the sleep command. This is the core of the plugin.
- An optional client-side component that displays a progress bar.


## Write the parser

After setting up an empty plugin, start by creating a `parser.py` file, and add the following code:

```py
import automancer as am

from . import namespace
from .process import Process

class Parser(am.BaseParser):
  namespace = namespace

  def __init__(self, fiber):
    super().__init__(fiber)

    self.transformers = [am.ProcessTransformer(Process, {
      'sleep': am.Attribute(
        description="Sleeps for a fixed duration.",
        type=am.PotentialExprType(am.QuantityType('second'))
      )
    }, parser=fiber)]

```

In this parser, you are declaring a single transformer which defines transformations on the layer being currently processed. In particular, the `ProcessTransformer` defines a lead transformer that will create a process named `Process`, which you will write in the next section.

The transformer only has a single attribute, `sleep` with a description (visible in the editor) and quantity type. Expressions are also allowed thanks to `PotentialExprType()`, therefore all of these are valid:

```yml
sleep: 1 sec
sleep: 10 min
sleep: {{ 1 * unit.sec }}
```


## Write the process

Create a `process.py` file, and add the following boilerplate code:

```py
from quantops import Quantity
import automancer as am

class ProcessLocation:
  duration: Quantity

  def export(self):
    return {
      "duration": self.duration.value
    }

class Process(am.BaseProcess[Quantity, None]):
  def __init__(self, data, /, master):
    ...

  def run(self, point, stack):
    ...
```

```diff
  class Process(am.BaseProcess[Quantity, None]):
    def __init__(self, data, /, master):
+     self._data = data

    def run(self, point, stack):
+     location = ProcessLocation(self._data)
+     yield ProcessExecEvent(location)
+
+     await asyncio.sleep(self._data)
+     yield ProcessTerminationEvent()
```

```diff
  class Process(am.BaseProcess[Quantity, None]):
+   def halt(self):
+     self._task.cancel()

    def run(self, point, stack):
      location = ProcessLocation(self._data)
      yield ProcessExecEvent(location)

-     await asyncio.sleep(self._data)
+     self._task = asyncio.create_task(asyncio.sleep(self._data))

+     try:
+       await self._task
+     except asyncio.CancelledError:
+       pass

      yield ProcessTerminationEvent()
```
